<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>YAXArrays.jl · SpectralIndices.jl</title><meta name="title" content="YAXArrays.jl · SpectralIndices.jl"/><meta property="og:title" content="YAXArrays.jl · SpectralIndices.jl"/><meta property="twitter:title" content="YAXArrays.jl · SpectralIndices.jl"/><meta name="description" content="Documentation for SpectralIndices.jl."/><meta property="og:description" content="Documentation for SpectralIndices.jl."/><meta property="twitter:description" content="Documentation for SpectralIndices.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SpectralIndices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SpectralIndices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SpectralIndices.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../basic_types/">Basics</a></li><li><a class="tocitem" href="../dataframes/">DataFrames.jl</a></li><li class="is-active"><a class="tocitem" href>YAXArrays.jl</a><ul class="internal"><li><a class="tocitem" href="#Computing-Kernels-for-kNDVI"><span>Computing Kernels for kNDVI</span></a></li></ul></li></ul></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../../api/axioms/">Axioms</a></li><li><a class="tocitem" href="../../api/compute/">Compute</a></li><li><a class="tocitem" href="../../api/datasets/">Datasets</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>YAXArrays.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>YAXArrays.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/awesome-spectral-indices/SpectralIndices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/awesome-spectral-indices/SpectralIndices.jl/blob/main/docs/src/tutorials/yaxarrays.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="YAXArrays.jl"><a class="docs-heading-anchor" href="#YAXArrays.jl">YAXArrays.jl</a><a id="YAXArrays.jl-1"></a><a class="docs-heading-anchor-permalink" href="#YAXArrays.jl" title="Permalink"></a></h1><p>This tutorial will illustrate how to use SpectralIndices.jl using YAXArrays.jl as input data.</p><p>First we need to download the data, like in the previous tutorial. Only this time the data is going to be higher dimensional and slightly more complex, hence the need for YAXArrays.jl. In order to do so we are going to use the <code>load_dataset</code> function:</p><pre><code class="language-julia hljs">using YAXArrays, DimensionalData
using SpectralIndices
yaxa = load_dataset(&quot;sentinel&quot;, YAXArray)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300×4 YAXArray{Int64,3}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:bands</span><span class="sgr31">}</span> Categorical{String} <span class="sgr36">String[&quot;B02&quot;, &quot;B03&quot;, &quot;B04&quot;, &quot;B08&quot;]</span> ForwardOrdered
Total size: 2.75 MB
</code></pre><p>As it is possible to observe we have a <code>YAXArray</code> object with three dimensions: <code>bands</code>, <code>x</code> and <code>y</code>. Each band is one of the 10 m spectral bands of a Sentinel-2 image.</p><p>The data is stored as <code>Int64</code>, so let us convert it to <code>Float</code> and rescale it:</p><pre><code class="language-julia hljs">yaxa = yaxa./10000</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300×4 YAXArray{Float64,3}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:bands</span><span class="sgr31">}</span> Categorical{String} <span class="sgr36">String[&quot;B02&quot;, &quot;B03&quot;, &quot;B04&quot;, &quot;B08&quot;]</span> ForwardOrdered
Total size: 2.75 MB
</code></pre><p>Now let&#39;s compute the NDVI for this dataset!</p><pre><code class="language-julia hljs">ndvi = compute_index(&quot;NDVI&quot;;
    N=yaxa[bands = At(&quot;B08&quot;)],
    R=yaxa[bands = At(&quot;B04&quot;)])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300 YAXArray{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points
Total size: 703.12 KB
</code></pre><p>As usual we can also just feed a properly constructed <code>YAXArray</code> to the <code>compute_index</code> function. Let&#39;s built the array:</p><pre><code class="language-julia hljs">index_R = findfirst(yaxa.bands.val .== &quot;B04&quot;)
index_N = findfirst(yaxa.bands.val .== &quot;B08&quot;)
new_bands_dim = Dim{:Variables}([&quot;R&quot;, &quot;N&quot;])

nr_data = cat(yaxa[:, :, index_R], yaxa[:, :, index_N], dims=3)
new_yaxa = YAXArray((yaxa.x, yaxa.y, new_bands_dim), nr_data)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300×2 YAXArray{Float64,3}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:Variables</span><span class="sgr31">}</span> Categorical{String} <span class="sgr36">String[&quot;R&quot;, &quot;N&quot;]</span> ReverseOrdered
Total size: 1.37 MB
</code></pre><p>!!!warn Please notice how the <code>Dim</code> is called <code>Variables</code>. This is needed for the internal computation to work properly.</p><p>Now that we have our <code>YAXArray</code> with the correctly names <code>Dim</code>s we can use it direcly into <code>compute_index</code>:</p><pre><code class="language-julia hljs">ndvi = compute_index(
    &quot;NDVI&quot;, new_yaxa
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300 YAXArray{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points
Total size: 703.12 KB
</code></pre><h2 id="Computing-Kernels-for-kNDVI"><a class="docs-heading-anchor" href="#Computing-Kernels-for-kNDVI">Computing Kernels for kNDVI</a><a id="Computing-Kernels-for-kNDVI-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Kernels-for-kNDVI" title="Permalink"></a></h2><p>We want to compute the kNDVI for a <code>YAXArray</code>. </p><pre><code class="language-julia hljs">kNDVI</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">kNDVI: Kernel Normalized Difference Vegetation Index
* Application Domain: kernel
* Bands/Parameters: Any[&quot;kNN&quot;, &quot;kNR&quot;]
* Formula: (kNN-kNR)/(kNN+kNR)
* Reference: https://doi.org/10.1126/sciadv.abc7447
</code></pre><p>As we see from <code>bands</code> we need the <code>kNN</code> and <code>kNR</code>. In order to compute these values SpectralIndices.jl provides a <code>compute_kernel</code> function. If you are curious about the <code>kNDVI</code> remember that you always have the source of the index in the <code>reference</code> field:</p><pre><code class="language-julia hljs">kNDVI.reference</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;https://doi.org/10.1126/sciadv.abc7447&quot;</code></pre><p>Onto the calculations:</p><pre><code class="language-julia hljs">knn = YAXArray((yaxa.x, yaxa.y), fill(1.0, 300, 300))
knr = compute_kernel(
    RBF;
    a = Float64.(yaxa[bands = At(&quot;B08&quot;)]),
    b = Float64.(yaxa[bands = At(&quot;B04&quot;)]),
    sigma = yaxa[bands = At(&quot;B08&quot;)].+yaxa[bands = At(&quot;B04&quot;)] ./ 2
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300 YAXArray{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points
Total size: 703.12 KB
</code></pre><p>As always, you can decide to build an <code>YAXArray</code> and feed that to the <code>compute_kernel</code> function if you prefer:</p><pre><code class="language-julia hljs">a = Float64.(yaxa[bands = At(&quot;B08&quot;)])
b = Float64.(yaxa[bands = At(&quot;B04&quot;)])
sigma = yaxa[bands = At(&quot;B08&quot;)].+yaxa[bands = At(&quot;B04&quot;)] ./ 2
kernel_dims = Dim{:Variables}([&quot;a&quot;, &quot;b&quot;, &quot;sigma&quot;])

params = concatenatecubes([a, b, sigma], kernel_dims)

knr = compute_kernel(RBF, params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300 YAXArray{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points
Total size: 703.12 KB
</code></pre><p>We can finally compute the kNDVI:</p><pre><code class="language-julia hljs">kndvi = compute_index(&quot;kNDVI&quot;; kNN = knn, kNR=knr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">300×300 YAXArray{Float64,2}<span class="sgr90"> with dimensions: </span>
  <span class="sgr31">Dim{</span><span class="sgr33">:x</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points,
  <span class="sgr31">Dim{</span><span class="sgr33">:y</span><span class="sgr31">}</span> Sampled{Int64} <span class="sgr36">1:300</span> ForwardOrdered Regular Points
Total size: 703.12 KB
</code></pre><p>Let&#39;s plot it!</p><pre><code class="language-julia hljs">using GLMakie
fig = Figure(resolution = (500, 500))
ax = Axis(fig[1, 1])
image!(ax, kndvi.data, colormap=:haline)
ylims!(300, 0)
fig</code></pre><img src="3424b4df.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dataframes/">« DataFrames.jl</a><a class="docs-footer-nextpage" href="../../api/axioms/">Axioms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 7 February 2024 09:00">Wednesday 7 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
